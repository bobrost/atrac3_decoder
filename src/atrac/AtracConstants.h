#pragma once

#include "util/MathUtil.h"
#include "util/ArrayUtil.h"
#include "util/HuffmanTable.h"

// Constants for ATRAC3 decoding
namespace Atrac3 {

  // The audio format type for ATRAC3 when encoded in a WAV file
  // 0x270, 16537 bytes per second, 384 byte block align
  constexpr uint16_t kWavFormatAtrac3 = 624;

  constexpr uint8_t kMagicHeaderLP2 = 0x28; // 40 decimal

  // 192 byte Sound Unit block align (mono channel)
  constexpr int kLP2BytesPerSoundUnitChannel = 192;
  // 384 bytes stereo block align (in WAV format chunk)
  constexpr int kLP2BytesPerStereoBlock = 384;
  constexpr int kLP2BytesPerSecond = 16537; // (384*43 + 25 bytes)

  // The total number of samples generated by rendering a sound unit (the left or
  // right channel within a frame). Note that a sound unit contains 4 subbands with
  // 256 frequencies each. The inverse mDCT generates 512 samples per subband, then
  // the two-stage inverse QMF combines them and generates a total of 2048 samples.
  // However, due to 50% overlap with neighboring frames, only 1024 final samples are
  // rendered per sound unit.
  constexpr int kNumOutputSamplesPerSoundUnit = 1024;

  // The number of samples for each of the 4 QMF subbands after inverse DCT
  constexpr int kNumSamplesPerSubband = 512;

  // The 1024-point frequency spectrum is split into 4 equal-sized subbands of 256 frequencies.
  constexpr int kNumSubbands = 4;

  // Total number of frequencies in the DCT arrays across all 4 subbands.
  constexpr int kNumFrequenciesInSpectrum = 1024;

  constexpr int kNumFrequenciesPerSubband = 256;

  // About tonal component encoding:
  // The full spectrum of an Atrac3 frame is 1024 frequencies, split by a QMF bank into 4
  // subbands of 256 frequencies each. For tonal encoding, each subband is partitioned further
  // into 4 tonal bins of 64 frequencies each. Within a tonal component, its starting position
  // in the full spectrum is based on the tonal bin, which is implicit from the bitstream order,
  // and an explicitly provided offset relative to that bin. All tonal components within a
  // single group have the same quantization step, coding mode, and number of values.
  constexpr int kNumTonalBinsPerSubband = 4;
  constexpr int kNumFrequenciesPerTonalBin = 64;
  constexpr int kMaxTonalComponentsPerGroup = 64;

  // An array of gain compensation points defines a scaling curve applied to one portion of
  // one subband. Note that each subband has 256 frequency values, which after the inverse
  // mDCT expands to 512 sample values, scaled by a scaling window. Each "location" within the
  // gain compensation curve is an 8-sample boundary, and the curve defines a 256 sample range,
  // including an ending value derived from the next frame's gain curves. The curve applies
  // to the overlapping window of the previous frame's second half of each subband and the
  // current frame's first half.
  constexpr int kNumSamplesPerGainCompensation = 256;

  // Maximum size of the gain compensation control point array, for any subband frame.
  constexpr int kMaxGainCompensationPointsPerSubband = 7;

    // Gain compensation level code corresponding to 1.0 gain
  constexpr int kGainCompensationNormalizedLevel = 4;



  // Total size of the mirrored coefficients array for QMF subband splitting or recombination.
  constexpr int kNumQmfCoefficients = 48;

  // Scale for the QMF coefficients when encoding / splitting
  constexpr float kQmfEncodingScale = 1.0f;

  // Scale for the QMF coefficients when decoding / combining
  constexpr float kQmfDecodingScale = 2.0f;




  // max tonal component groups per frame = 31


  class Atrac3Constants {
   public:
    Atrac3Constants();

    // 512-sample scaling window applied to each QMF subband before MDCT during encoding.
    FloatArray encodingScalingWindow;

    // 512-sample inverse scaling window applied to each QMF subband after inverse
    // DCT transform during decoding, to prescale each window before QMF neighbor
    // overlap and recombination.
    FloatArray decodingScalingWindow;

    // Scale factors are powers of 2, with the exponent in steps of 1/3, ranging
    // from 2^-5 to 2^16. These are used in representing amplitudes in the frequency
    // spectrum, where each amplitude is an N-bit-quantized integer multiplied by
    // a scale factor.
    FloatArray scaleFactors; // TODO: rename? amplitude scale factors? spectrum scale?

    // TODO: is this needed, different from just direct lookup?
    float getScaleFactor(int scaleFactorIndex) const;


    // Scaling from the normalized amplitude range [-1,1] to each huffman coding
    // table's integer mantissas. These values are each table's maximum quantization + 0.5.    
    // For table 1, this takes into account the {-1, 0, +1} values generated by that
    // table's indirection.
    FloatArray maxQuantization = {
      0.0f, 1.5f, 2.5f, 3.5f, 4.5f, 7.5f, 15.5f, 31.5f
    };

    // Inverse scaling from each table's integer mantissas to normalized
    // range. This is the inverse of kMaxQuantization, without dividing
    // by zero for table 0.
    FloatArray inverseQuantization = {
      0.0f, 1.0f/1.5f, 1.0f/2.5f, 1.0f/3.5f, 1.0f/4.5f, 1.0f/7.5f, 1.0f/15.5f, 1.0f/31.5f
    };

    // For gain compensation, The scale multipliers indexed by each
    // gain data point levelCode. The locationCode is an 8-sample offset.
    // Gain levels are ramped from a location/level over 8 samples
    // to the next level, then held constant to the next position.
    FloatArray gainCompensationLevelTable;

    // The encoding spectral subband ranges for the Block Floating Units (BFUs)
    // have increasing power of 2 sizes. This array defines the starting (and ending)
    // offset for each BFU. After tonal component encoding, each encoded range of the
    // residual spectrum consists of all frequency indices within one of these
    // BFU subsets.
    std::vector<int> bfuSubbandOffsets = {
      0,8,16,24,32,40,48,56, // 8 bands of size 8
      64,80,96,112,128,144,160,176, // 8 bands of size 16
      192, 224,256,288,320,352,384,416,448,480, // 10 bands of size 32
      512,576,640,704, // 4 bands of size 64
      768,896, // 2 bands of size 128
      1024}; // final offset past end of blocks

    // Convert the given BFU block index to a corresponding range of frequency indices
    // within the full 1024 frequency spectrum, for encoding or decoding spectral components.
    bool getSpectralSubbandOffsets(int blockIndex, int& resultStart, int& resultSize) const;


    // Mantissa lookup table used for Variable Length Coding only with Huffman table
    // selector 1. The Huffman table encodes the index values 0 through 8, which are
    // used as lookup indices in this mantissa table. There are 9 possible paired
    // orderings of the set (-1, 0, and 1), interleave-encoded in this table as 18 values,
    // allowing each single Huffman code to specify two mantissa values.
    //
    // Evaluating the efficacy of this approach, a straight Huffman-coding from the
    // set (-1,0,1) requires 1 or 2 bits per value, with an average 1.66 bits per value.
    // Assuming equal probability, this indirect mantissa pair approach takes an
    // average 1.94 bits per value. For the 5 pairs where either value is 0, the
    // compression is 1.5 bits per value; the other pairs each use 2.5 bits per value.
    // The savings are most apparent in a stream of many pairs of consecutive zeroes,
    // allowing compression as small as 0.5 bits per value.
    std::vector<int> vlcTable1Mantissas = {
      0, 0, 0, 1, 0, -1, 1, 0, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1
    };

    // Lookup table to tell how many bits are used for constant length coding.
    // Note: table 0 is invalid
    // TODO: Investigate what table 1 means. table 1 reads 4 bits but interleaves by 2?
    //   Previously, my note found it's actually just 2 bits. Enforced even number of values?
    std::vector<int> constantLengthNumBits = { 0, 2, 3, 3, 4, 4, 5, 6 };

    // The standard Sony-published coefficients for QMF encoding and decoding.
    // This is the first half of the array. The full 48-coefficient array is
    // generated by mirroring these values, where value[i] = value[47-i].
    //
    // As a theoretical note, these coefficients are fixed for decoding and must
    // be used as-is for deterministic output, but they don't necessarily have to
    // be used this way for encoding...
    FloatArray qmfHalfCoefficients = {
      -0.00001461907f,  -0.00009205479f, -0.000056157569f,  0.00030117269f,
      0.0002422519f,    -0.00085293897f, -0.0005205574f,    0.0020340169f,
      0.00078333891f,   -0.0042153862f,  -0.00075614988f,   0.0078402944f,
      -0.000061169922f, -0.01344162f,    0.0024626821f,     0.021736089f,
      -0.007801671f,    -0.034090221f,   0.01880949f,       0.054326009f,
      -0.043596379f,    -0.099384367f,   0.13207909f,       0.46424159f
    };

    // 8 Huffman tables
    std::vector<HuffmanTable> huffmanTables;

  };

} // namespace Atrac3